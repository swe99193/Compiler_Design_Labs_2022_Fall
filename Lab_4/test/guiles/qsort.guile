(define (make-generator procedure)
  (define last-return values)
  (define last-value #f)
  (define (last-continuation _)
    (let ((result (procedure yield)))
      (last-return result)))
  (define (yield value)
    (call/cc (lambda (continuation)
               (set! last-value value)
               (last-return value))))
  (lambda args
    (call/cc (lambda (return)
               (set! last-return return)
                 (if (null? args)
                   (last-continuation last-value)
                   (apply last-continuation args))))))
(define (div x y) (if (and (exact-integer? x) (exact-integer? y)) (floor/ x y) (/ x y)))(define (pascal-display x)
  (cond ((and (not (exact-integer? x)) (real? x)) (display (exact->inexact x)))
        ((eq? x #t) (display 1))
        ((eq? x #f) (display 0))
        (#t (display x))))
(define main (lambda () (make-generator (lambda (return) (define i 0)(define j 0)(define tmp 0)(define size 0) (define arr (make-array 0 '(1 50) ))  (define readArr (lambda (a  ) (make-generator (lambda (return) (define input 0) (begin (set! size 0) (set! input (read)) (letrec ([loop (lambda () (if (not (eq? input 0)) (begin (begin (set! size (+ size 1)) (array-cell-set! arr input size ) (set! input (read)) ) (loop))))]) (loop)) ))))) (define split (lambda (start stop  ) (make-generator (lambda (return) (define test 0) (define left 0)(define right 0) (define pivot 0) (define tmp 0) (begin (set! pivot (array-cell-ref arr start )) (set! left (+ start 1)) (set! right stop) (letrec ([loop (lambda () (if (<= left right) (begin (begin (set! test 1) (if (not (<= left stop)) (begin (set! test 0))) (if (eq? test 1) (begin (if (not (< (array-cell-ref arr left ) pivot)) (begin (set! test 0)))) (begin 0 )) (letrec ([loop (lambda () (if (eq? test 1) (begin (begin (set! left (+ left 1)) (set! test 1) (if (not (<= left stop)) (begin (set! test 0))) (if (eq? test 1) (begin (if (not (< (array-cell-ref arr left ) pivot)) (begin (set! test 0)))) (begin 0 )) ) (loop))))]) (loop)) (set! test 1) (if (not (> right start)) (begin (set! test 0))) (if (eq? test 1) (begin (if (not (>= (array-cell-ref arr right ) pivot)) (begin (set! test 0)))) (begin 0 )) (letrec ([loop (lambda () (if (eq? test 1) (begin (begin (set! right (- right 1)) (set! test 1) (if (not (> right start)) (begin (set! test 0))) (if (eq? test 1) (begin (if (not (>= (array-cell-ref arr right ) pivot)) (begin (set! test 0)))) (begin 0 )) ) (loop))))]) (loop)) (if (< left right) (begin (begin (set! tmp (array-cell-ref arr left )) (array-cell-set! arr (array-cell-ref arr right ) left ) (array-cell-set! arr tmp right ) )) (begin 0 )) ) (loop))))]) (loop)) (set! tmp (array-cell-ref arr start )) (array-cell-set! arr (array-cell-ref arr right ) start ) (array-cell-set! arr tmp right ) (return right) ))))) (define quicksortRecur (lambda (start stop  ) (make-generator (lambda (return) (define m 0) (define splitpt 0) (begin (if (< start stop) (begin (begin (set! splitpt ((split start stop ))) ((quicksortRecur start (- splitpt 1) )) ((quicksortRecur (+ splitpt 1) stop )) )) (begin 0 )) ))))) (define quicksort (lambda (arr  ) (make-generator (lambda (return) (begin ((quicksortRecur 1 size )) )))))  (begin ((readArr arr )) ((quicksort arr )) (set! i 1) (letrec ([loop (lambda () (if (<= i size) (begin (begin (pascal-display (array-cell-ref arr i )) (newline) (set! i (+ i 1)) ) (loop))))]) (loop)) )))))

((main))
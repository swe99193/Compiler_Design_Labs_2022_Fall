(define (make-generator procedure)
  (define last-return values)
  (define last-value #f)
  (define (last-continuation _)
    (let ((result (procedure yield)))
      (last-return result)))
  (define (yield value)
    (call/cc (lambda (continuation)
               (set! last-value value)
               (last-return value))))
  (lambda args
    (call/cc (lambda (return)
               (set! last-return return)
                 (if (null? args)
                   (last-continuation last-value)
                   (apply last-continuation args))))))
(define (div x y) (if (and (exact-integer? x) (exact-integer? y)) (floor/ x y) (/ x y)))(define (pascal-display x)
  (cond ((and (not (exact-integer? x)) (real? x)) (display (exact->inexact x)))
        ((eq? x #t) (display 1))
        ((eq? x #f) (display 0))
        (#t (display x))))
(define main (lambda () (make-generator (lambda (return) (define a (make-array 0 '(1 2) )) (define b 0) (define c (make-array 0 '(1 2) '(1 2) ))   (begin (array-cell-set! a 1 1 ) (array-cell-set! a 2 2 ) (array-cell-set! c (array-cell-ref a 1 ) 1 1 ) (array-cell-set! c (array-cell-ref a 2 ) 1 2 ) (array-cell-set! c (+ (array-cell-ref a 2 ) (array-cell-ref a 1 )) 2 1 ) (array-cell-set! c (+ (array-cell-ref a 2 ) (array-cell-ref a 2 )) 2 2 ) (pascal-display (+ (+ (+ (array-cell-ref c 1 1 ) (array-cell-ref c 1 2 )) (array-cell-ref c 2 1 )) (array-cell-ref c 2 2 ))) (newline) )))))

((main))